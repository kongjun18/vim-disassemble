" Disassembly plgin for Vim
" Last Change: 2021-03-17
" Author: Kong Jun <kongjun18@outlook.com>
" Github: https://github.com/kongjun18
" License: GPL-2.0
"
" Note:
" 1. Only test GNU toolchain on GNU/Linux(Fedora 33)
" 2. Only support whole file disassembly
"
" TODO:
" 1. support visual mode selection
" 3. use asynchronous API
" 4. compile source code only when buffer is modified
" 2. support float window???
"
" Configuration:
" |---------------------------+-----------------------------------------------------------------|
" | variable                  | meaning                                                         |
" |---------------------------+-----------------------------------------------------------------|
" | disassembly_compiler      | compiler command                                                |
" | disassembly_objdump       | objdump command                                                 |
" | disassembl_compile_flags  | flags used to compile source code                               |
" | disassembly_objdump_flags | flags used to disassembly executable                            |
" | disassembly_source        | whether or not to generate assembly file from compiler directly |
" | disassembly_directory     | place all itermidiate files in it                               |
" | disassembly_executable    | disassembly this executable directly                            |
" | loaded_disassembly        | whether or not to load this plugin                              |
" | disassembly_no_command    | whether or not to create command :Disassembly                   |
" |---------------------------+-----------------------------------------------------------------|

" guard
if exists('g:loaded_disassembly') || &cp || version < 700
    finish
endif
let g:loaded_disassembly = 1

" wrapper of get()
function s:get(variable, default)
    if type(a:default) == v:t_list
        call assert_equal(type(a:variable), type(a:default))
        let l:var = get(b:, a:variable, get(g:, a:variable, []))
        return extend(l:var, a:default)
    else
        return get(b:, a:variable, get(g:, a:variable, a:default))
    endif
endfunction

" wrapper of :execute, die when encounter error
function s:execute(...)
    if empty(a:000)
        return
    endif
    let l:command = join(a:000)
    silent exec l:command
    if v:shell_error
        echoerr 'vim-assembly: failed to execute ' l:command
    endif
endfunction

function g:disassembly#disassembly() abort
    let l:file = expand('%:p')
    if empty(l:file)
        echoerr "Can't disassembly empty buffer"
        return
    endif

    " get toolchain and flags
    let l:compiler = ''
    let l:objdump = s:get('disassembly_objdump', 'objdump')
    let l:objdump_flags = join(s:get('disassembly_objdump_flags', ['-d', '-C', '-M sufix']))
    let l:compile_flags = join(s:get('disassembly_compile_flags', ['-S'])) " disassembly current file
    if &filetype == 'c'
        let l:compiler = s:get(disassembly_compiler, 'gcc')
    elseif &filetype == 'cpp'
        let l:compiler = s:get(disassembly_compiler, 'g++')
    else
        echoerr 'vim-disassembly only supports C/C++'
    endif

    let l:assembly_file = s:get(disassembly_directory) . substitute(expand('%:t'), '\..*$', '\.s', '') " remove extensiton name
    let l:executable = s:get('disassembly_executable', '')

    " disassembly executable directly
    if !empty(l:executable)
        s:execute(l:objdump, l:objdump_flags, l:executable, '>', l:assembly_file)
        return
    endif

    " use assembly file generated by compiler
    if (s:get('disassembly_source', v:true))
        s:execute(l:compiler, l:compile_flags, l:flag, '>', l:assembly_file)
        return
    " compile and disassembly
    else
        let l:compiler_flags = join(s:get('disassembly_compile_flags'), '')
        s:execute(l:compiler, l:compile_flags, '-o', l:executable)
        s:execute(l:objdump, l:objdump_flags, '>', l:assembly_file)
        return
    endif

    " buffer is no existed or hiddend
    if !bufexists(l:file) || bufexists(l:file) && empty(getbufinfo(l:file)[0].windows)
        execute 'vsp ' .. l:file
        " when we disassembly again, the buffer will change automatically
        call setbufvar(l:file, '&autoread', 1)
        let src_window_id = win_getid(winnr('#'))
        call win_gotoid(src_window_id)
    else
        if !bufloaded(l:file)
            call bufload(l:file)
        endif
    endif
endfunction

