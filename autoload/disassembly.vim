" Disassembly plgin for Vim
" Last Change: 2021-03-18
" Author: Kong Jun <kongjun18@outlook.com>
" Github: https://github.com/kongjun18
" License: GPL-2.0
"
" Note:
" 1. Only test GNU toolchain on GNU/Linux(Fedora 33)
" 2. Only support whole file disassembly
"
" TODO:
" 1. support visual mode selection
" 3. use asynchronous API
" 4. compile source code only when buffer is modified
" 2. support float window???
"
" Configuration:
" |---------------------------+-----------------------------------------------------------------|
" | variable                  | meaning                                                         |
" |---------------------------+-----------------------------------------------------------------|
" | disassembly_compiler      | compiler command                                                |
" | disassembly_objdump       | objdump command                                                 |
" | disassembl_compile_flags  | flags used to compile source code                               |
" | disassembly_objdump_flags | flags used to disassembly executable                            |
" | disassembly_source        | whether or not to generate assembly file from compiler directly |
" | disassembly_directory     | place all itermidiate files in it                               |
" | disassembly_executable    | disassembly this executable directly                            |
" | disassembly_loaded        | whether or not to load this plugin                              |
" | disassembly_no_command    | whether or not to create command :Disassembly                   |
" |---------------------------+-----------------------------------------------------------------|

" guard
if exists('g:disassembly_loaded') || &cp || v:version < 800
    finish
endif
let g:disassembly_loaded = 1

" wrapper of get()
function s:get(variable, default)
    if type(a:default) == v:t_list
        call assert_equal(type(a:variable), type(a:default))
        let l:var = get(b:, a:variable, get(g:, a:variable, []))
        return extend(l:var, a:default)
    else
        return get(b:, a:variable, get(g:, a:variable, a:default))
    endif
endfunction

" wrapper of :execute, die when encounter error
function s:execute(...)
    if empty(a:000)
        return
    endif
    let l:command = join(a:000)
    :echomsg l:command
    silent exec '!'l:command
    if v:shell_error
        echoerr 'vim-assembly: failed to execute ' l:command
    endif
endfunction

function g:disassembly#disassembly() abort
    let l:source_file = expand('%:p')
    if empty(l:source_file)
        echoerr "Can't disassembly empty buffer"
        return
    endif

    " get toolchain and flags
    let l:compiler = ''
    let l:objdump = s:get('disassembly_objdump', 'objdump')
    let l:objdump_flags = join(s:get('disassembly_objdump_flags', ['-C', '-S', '-M sufix'])) " disassemble & demangle & show source code & keep suffix
    let l:compile_flags = join(s:get('disassembly_compile_flags', ['-S'])) " disassembly current file
    if &filetype == 'c'
        let l:compiler = s:get('disassembly_compiler', 'gcc')
    elseif &filetype == 'cpp'
        let l:compiler = s:get('disassembly_compiler', 'g++')
    else
        echoerr 'vim-disassembly only supports C/C++'
    endif

    let l:assembly_file = s:get('disassembly_directory', '/tmp') .. '/' .. substitute(expand('%:t'), '\..*$', '\.s', '') " remove extensiton name
    let l:executable = s:get('disassembly_executable', '')

    " disassembly executable directly
    if !empty(l:executable)
        call s:execute(l:objdump, l:objdump_flags, l:executable, '>', l:assembly_file)
    else
        " use assembly file generated by compiler
        if (s:get('disassembly_source', v:true))
            call s:execute(l:compiler, l:compile_flags, l:source_file, '-o', l:assembly_file)
        " compile and disassembly
        else
            let l:executable = s:get('disassembly_directory', '/tmp') .. '/' .. substitute(expand('%:t'), '\..*$', '\.out', '')
            let l:compile_flags = join(s:get('disassembly_compile_flags', ['']))
            call s:execute(l:compiler, l:compile_flags, l:source_file,'-o', l:executable)
            " 为什么无法访问到 executable 和 objdump_flags
            " 前缀变量怎样用
            call s:execute(l:objdump, l:objdump_flags, l:executable, '>', l:assembly_file)
        endif
    endif


    " buffer is no existed or hiddend
    if !bufexists(l:assembly_file) || bufexists(l:assembly_file) && empty(getbufinfo(l:assembly_file)[0].windows)
        execute 'vsp ' .. l:assembly_file
        " when we disassembly again, the buffer will change automatically
        call setbufvar(l:assembly_file, '&autoread', 1)
        let src_window_id = win_getid(winnr('#'))
        call win_gotoid(src_window_id)
    else
        if !bufloaded(l:assembly_file)
            call bufload(l:assembly_file)
        endif
    endif
endfunction

